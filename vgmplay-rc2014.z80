;
; VGM Player for RC2014 Z80 Computer
; Port of the original Amstrad CPC VGM Player
;
; Original Authors: Shinra team - PulkoMandy, OffseT and Zik
; Original Project: https://framagit.org/shinra/vgmplay
; RC2014 Port: jduraes
;
; Required:
;   - VGM files must be uncompressed
;   - OPL3 sound card (suggested I/O ports: 0x60-0x61 for page 1, 0x62-0x63 for page 2)
;   - AY-3-8912 sound card (suggested I/O port: 0xA0 for register, 0xA1 for data)
;   - CP/M 2.2 or compatible
;
; RC2014 I/O Port Assignments (suggestions):
; 0x60 - OPL3 Page 1 Register Port
; 0x61 - OPL3 Page 1 Data Port  
; 0x62 - OPL3 Page 2 Register Port
; 0x63 - OPL3 Page 2 Data Port
; 0xA0 - AY Register Select Port
; 0xA1 - AY Data Port
;
; These ports are chosen to avoid conflicts with common RC2014 peripherals:
; - Serial: 0x80-0x87 (SIO)
; - CF Card: 0x10-0x17
; - RTC: 0x70-0x73
; - Digital I/O: 0x00-0x07
; - Memory banking: 0x78-0x7B

; I/O Port definitions
OPL3_PAGE1_REG  EQU 0x60
OPL3_PAGE1_DATA EQU 0x61
OPL3_PAGE2_REG  EQU 0x62
OPL3_PAGE2_DATA EQU 0x63
AY_REG_PORT     EQU 0xA0
AY_DATA_PORT    EQU 0xA1

; CP/M BDOS function calls
BDOS_CONIN      EQU 1   ; Console input
BDOS_CONOUT     EQU 2   ; Console output
BDOS_PSTRING    EQU 9   ; Print string
BDOS_CONSTAT    EQU 11  ; Console status
BDOS_OPEN       EQU 15  ; Open file
BDOS_CLOSE      EQU 16  ; Close file
BDOS_READ       EQU 20  ; Read sequential
BDOS_SETDMA     EQU 26  ; Set DMA address

; CP/M system addresses
BDOS_ENTRY      EQU 0x0005
TPA_START       EQU 0x0100
DEFAULT_FCB     EQU 0x005C
DEFAULT_DMA     EQU 0x0080

; Buffer size - smaller than original for CP/M memory constraints
BufLen          EQU 128

; CP/M .COM file starts at 0x0100
                ORG TPA_START

; CP/M entry point
Start:
    ; Check if filename was provided in default FCB
    ld a,(DEFAULT_FCB+1)
    cp ' '              ; Space means no filename
    jp z,ShowUsage
    
    ; Set up our own DMA buffer
    ld de,DMABuffer
    ld c,BDOS_SETDMA
    call BDOS_ENTRY
    
    ; Open the VGM file
    call OpenVGMFile
    jp nz,Exit
    
    ; Read and verify VGM header
    call ReadBuffer
    jp nz,Exit
    
    ; Check for "Vgm" identifier
    ld hl,DMABuffer
    ld (BufCur),hl
    ld bc,BufLen
    ld (BufLeft),bc
    
    ld a,'V'
    cp (hl)
    jp nz,BadFile
    inc hl
    ld a,'g'
    cp (hl)
    jp nz,BadFile
    inc hl  
    ld a,'m'
    cp (hl)
    jp nz,BadFile
    
    ; Parse VGM header - simplified version
    ; Skip to data start (offset 0x34 in header, but we'll use fixed offset 0x40)
    ld hl,DMABuffer+0x40
    ld (MusicStart),hl
    ld (MusicLoop),hl     ; For simplicity, loop = start
    
    ; Initialize timing
    xor a
    ld (TimerLo),a
    ld (TimerHi),a
    
    ; Reset sound chips
    call ResetOPL3
    call ResetAY
    
    ; Main playback loop
MainLoop:
    ; Check for keypress (ESC to exit)
    ld c,BDOS_CONSTAT
    call BDOS_ENTRY
    or a
    jr z,NoKey
    
    ; Get the key
    ld c,BDOS_CONIN
    call BDOS_ENTRY
    cp 27               ; ESC key
    jp z,Exit
    
NoKey:
    ; Get next VGM command
    call GetByte
    jp nc,Exit          ; End of data
    
    ; Process VGM commands
    cp 0x5A             ; OPL2 register
    jr z,SendRegOPLPage1
    
    cp 0x5B             ; OPL1 register  
    jr z,SendRegOPLPage1
    
    cp 0x5E             ; OPL3 page 1 register
    jr z,SendRegOPLPage1
    
    cp 0x5F             ; OPL3 page 2 register
    jr z,SendRegOPLPage2
    
    cp 0x61             ; Custom delay
    jr z,DelayCustom
    
    cp 0x62             ; 1/60s delay  
    jr z,DelayFrame60
    
    cp 0x63             ; 1/50s delay
    jr z,DelayFrame50
    
    cp 0x66             ; End of stream
    jp z,RestartLoop
    
    cp 0xA0             ; AY register
    jr z,SendRegAY
    
    ; Short delays (0x70-0x7F)
    cp 0x70
    jr c,Unknown
    cp 0x80
    jr c,DelayShort
    
Unknown:
    ; Print unknown command as hex
    call PrintHex
    jp MainLoop

SendRegOPLPage1:
    call GetByte
    jp nc,Exit
    ld d,a              ; Register
    
    call GetByte  
    jp nc,Exit
    ld e,a              ; Data
    
    ; Send to OPL3 Page 1
    ld a,d
    out (OPL3_PAGE1_REG),a
    ld a,e
    out (OPL3_PAGE1_DATA),a
    
    jp MainLoop

SendRegOPLPage2:
    call GetByte
    jp nc,Exit
    ld d,a              ; Register
    
    call GetByte
    jp nc,Exit
    ld e,a              ; Data
    
    ; Send to OPL3 Page 2  
    ld a,d
    out (OPL3_PAGE2_REG),a
    ld a,e
    out (OPL3_PAGE2_DATA),a
    
    jp MainLoop

SendRegAY:
    call GetByte
    jp nc,Exit
    ld d,a              ; Register
    
    call GetByte
    jp nc,Exit  
    ld e,a              ; Data
    
    ; Send to AY-3-8912
    ld a,d
    out (AY_REG_PORT),a
    ld a,e
    out (AY_DATA_PORT),a
    
    jp MainLoop

DelayShort:
    sub 0x6F            ; Convert to delay value (1-16)
    ld e,a
    ld d,0
    jr DoDelay

DelayFrame60:
    ld de,735           ; 44100/60 = 735 samples
    jr DoDelay

DelayFrame50:  
    ld de,882           ; 44100/50 = 882 samples
    jr DoDelay

DelayCustom:
    call GetByte
    jp nc,Exit
    ld e,a
    
    call GetByte
    jp nc,Exit
    ld d,a
    
DoDelay:
    ; Simple delay implementation - just loop
    ; In a real implementation, this should be tied to system timing
DelayLoop:
    ld a,d
    or e
    jp z,MainLoop
    dec de
    
    ; Small CPU delay
    nop
    nop
    nop
    nop
    
    jr DelayLoop

RestartLoop:
    ; Reset to beginning (simplified)
    ld hl,(MusicLoop)
    ld (BufCur),hl
    ld bc,BufLen
    ld (BufLeft),bc
    jp MainLoop

; Get next byte from buffer
GetByte:
    ld bc,(BufLeft)
    ld a,b
    or c
    jr z,GetNewBuffer
    
    ld hl,(BufCur)
    ld a,(hl)
    inc hl
    ld (BufCur),hl
    dec bc
    ld (BufLeft),bc
    
    scf                 ; Success
    ret

GetNewBuffer:
    call ReadBuffer
    jr z,GetByte
    or a                ; Clear carry - no more data
    ret

; Read buffer from file
ReadBuffer:
    ; For CP/M, we need to implement proper file I/O
    ; This is simplified - in real implementation should handle EOF properly
    ld bc,BufLen
    ld (BufLeft),bc
    ld hl,DMABuffer
    ld (BufCur),hl
    xor a               ; Return success
    ret

; Reset OPL3 chip
ResetOPL3:
    ; Reset all OPL3 registers to 0
    ld b,0xFF
ResetOPL3Loop1:
    ld a,b
    out (OPL3_PAGE1_REG),a
    xor a
    out (OPL3_PAGE1_DATA),a
    djnz ResetOPL3Loop1
    
    ld b,0xFF  
ResetOPL3Loop2:
    ld a,b
    out (OPL3_PAGE2_REG),a
    xor a
    out (OPL3_PAGE2_DATA),a
    djnz ResetOPL3Loop2
    ret

; Reset AY chip  
ResetAY:
    ld b,16             ; 16 AY registers (0-15)
    ld c,0
ResetAYLoop:
    ld a,c
    out (AY_REG_PORT),a
    xor a
    out (AY_DATA_PORT),a
    inc c
    djnz ResetAYLoop
    ret

; Open VGM file using CP/M
OpenVGMFile:
    ld de,DEFAULT_FCB
    ld c,BDOS_OPEN
    call BDOS_ENTRY
    cp 0xFF             ; 0xFF = file not found
    ret

; Print hex value in A
PrintHex:
    push af
    rra
    rra  
    rra
    rra
    and 0x0F
    call PrintHexNibble
    pop af
    and 0x0F
    call PrintHexNibble
    ret

PrintHexNibble:
    cp 10
    jr c,PrintDigit
    add 'A'-10
    jr PrintChar
PrintDigit:
    add '0'
PrintChar:
    ld e,a
    ld c,BDOS_CONOUT
    call BDOS_ENTRY
    ret

ShowUsage:
    ld de,UsageMsg
    ld c,BDOS_PSTRING
    call BDOS_ENTRY
    jp Exit

BadFile:
    ld de,BadFileMsg  
    ld c,BDOS_PSTRING
    call BDOS_ENTRY
    jp Exit

Exit:
    ; Reset sound chips
    call ResetOPL3
    call ResetAY
    
    ; Close file
    ld de,DEFAULT_FCB
    ld c,BDOS_CLOSE
    call BDOS_ENTRY
    
    ; Return to CP/M
    ret

; Messages
UsageMsg:
    db 'VGM Player for RC2014',13,10
    db 'Usage: VGMPLAY filename.vgm',13,10
    db '$'

BadFileMsg:
    db 'Error: Not a valid VGM file',13,10,'$'

; Variables
MusicStart:     dw 0
MusicLoop:      dw 0
BufLeft:        dw 0
BufCur:         dw 0
TimerLo:        db 0
TimerHi:        db 0

; DMA buffer for file I/O
DMABuffer:      ds BufLen
